/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/store2";
exports.ids = ["vendor-chunks/store2"];
exports.modules = {

/***/ "(ssr)/./node_modules/store2/dist/store2.js":
/*!********************************************!*\
  !*** ./node_modules/store2/dist/store2.js ***!
  \********************************************/
/***/ (function(module) {

eval("/*! store2 - v2.14.2 - 2022-07-18\n* Copyright (c) 2022 Nathan Bubna; Licensed (MIT OR GPL-3.0) */\n;(function(window, define) {\n    var _ = {\n        version: \"2.14.2\",\n        areas: {},\n        apis: {},\n        nsdelim: '.',\n\n        // utilities\n        inherit: function(api, o) {\n            for (var p in api) {\n                if (!o.hasOwnProperty(p)) {\n                    Object.defineProperty(o, p, Object.getOwnPropertyDescriptor(api, p));\n                }\n            }\n            return o;\n        },\n        stringify: function(d, fn) {\n            return d === undefined || typeof d === \"function\" ? d+'' : JSON.stringify(d,fn||_.replace);\n        },\n        parse: function(s, fn) {\n            // if it doesn't parse, return as is\n            try{ return JSON.parse(s,fn||_.revive); }catch(e){ return s; }\n        },\n\n        // extension hooks\n        fn: function(name, fn) {\n            _.storeAPI[name] = fn;\n            for (var api in _.apis) {\n                _.apis[api][name] = fn;\n            }\n        },\n        get: function(area, key){ return area.getItem(key); },\n        set: function(area, key, string){ area.setItem(key, string); },\n        remove: function(area, key){ area.removeItem(key); },\n        key: function(area, i){ return area.key(i); },\n        length: function(area){ return area.length; },\n        clear: function(area){ area.clear(); },\n\n        // core functions\n        Store: function(id, area, namespace) {\n            var store = _.inherit(_.storeAPI, function(key, data, overwrite) {\n                if (arguments.length === 0){ return store.getAll(); }\n                if (typeof data === \"function\"){ return store.transact(key, data, overwrite); }// fn=data, alt=overwrite\n                if (data !== undefined){ return store.set(key, data, overwrite); }\n                if (typeof key === \"string\" || typeof key === \"number\"){ return store.get(key); }\n                if (typeof key === \"function\"){ return store.each(key); }\n                if (!key){ return store.clear(); }\n                return store.setAll(key, data);// overwrite=data, data=key\n            });\n            store._id = id;\n            try {\n                var testKey = '__store2_test';\n                area.setItem(testKey, 'ok');\n                store._area = area;\n                area.removeItem(testKey);\n            } catch (e) {\n                store._area = _.storage('fake');\n            }\n            store._ns = namespace || '';\n            if (!_.areas[id]) {\n                _.areas[id] = store._area;\n            }\n            if (!_.apis[store._ns+store._id]) {\n                _.apis[store._ns+store._id] = store;\n            }\n            return store;\n        },\n        storeAPI: {\n            // admin functions\n            area: function(id, area) {\n                var store = this[id];\n                if (!store || !store.area) {\n                    store = _.Store(id, area, this._ns);//new area-specific api in this namespace\n                    if (!this[id]){ this[id] = store; }\n                }\n                return store;\n            },\n            namespace: function(namespace, singleArea, delim) {\n                delim = delim || this._delim || _.nsdelim;\n                if (!namespace){\n                    return this._ns ? this._ns.substring(0,this._ns.length-delim.length) : '';\n                }\n                var ns = namespace, store = this[ns];\n                if (!store || !store.namespace) {\n                    store = _.Store(this._id, this._area, this._ns+ns+delim);//new namespaced api\n                    store._delim = delim;\n                    if (!this[ns]){ this[ns] = store; }\n                    if (!singleArea) {\n                        for (var name in _.areas) {\n                            store.area(name, _.areas[name]);\n                        }\n                    }\n                }\n                return store;\n            },\n            isFake: function(force) {\n                if (force) {\n                    this._real = this._area;\n                    this._area = _.storage('fake');\n                } else if (force === false) {\n                    this._area = this._real || this._area;\n                }\n                return this._area.name === 'fake';\n            },\n            toString: function() {\n                return 'store'+(this._ns?'.'+this.namespace():'')+'['+this._id+']';\n            },\n\n            // storage functions\n            has: function(key) {\n                if (this._area.has) {\n                    return this._area.has(this._in(key));//extension hook\n                }\n                return !!(this._in(key) in this._area);\n            },\n            size: function(){ return this.keys().length; },\n            each: function(fn, fill) {// fill is used by keys(fillList) and getAll(fillList))\n                for (var i=0, m=_.length(this._area); i<m; i++) {\n                    var key = this._out(_.key(this._area, i));\n                    if (key !== undefined) {\n                        if (fn.call(this, key, this.get(key), fill) === false) {\n                            break;\n                        }\n                    }\n                    if (m > _.length(this._area)) { m--; i--; }// in case of removeItem\n                }\n                return fill || this;\n            },\n            keys: function(fillList) {\n                return this.each(function(k, v, list){ list.push(k); }, fillList || []);\n            },\n            get: function(key, alt) {\n                var s = _.get(this._area, this._in(key)),\n                    fn;\n                if (typeof alt === \"function\") {\n                    fn = alt;\n                    alt = null;\n                }\n                return s !== null ? _.parse(s, fn) :\n                    alt != null ? alt : s;\n            },\n            getAll: function(fillObj) {\n                return this.each(function(k, v, all){ all[k] = v; }, fillObj || {});\n            },\n            transact: function(key, fn, alt) {\n                var val = this.get(key, alt),\n                    ret = fn(val);\n                this.set(key, ret === undefined ? val : ret);\n                return this;\n            },\n            set: function(key, data, overwrite) {\n                var d = this.get(key),\n                    replacer;\n                if (d != null && overwrite === false) {\n                    return data;\n                }\n                if (typeof overwrite === \"function\") {\n                    replacer = overwrite;\n                    overwrite = undefined;\n                }\n                return _.set(this._area, this._in(key), _.stringify(data, replacer), overwrite) || d;\n            },\n            setAll: function(data, overwrite) {\n                var changed, val;\n                for (var key in data) {\n                    val = data[key];\n                    if (this.set(key, val, overwrite) !== val) {\n                        changed = true;\n                    }\n                }\n                return changed;\n            },\n            add: function(key, data, replacer) {\n                var d = this.get(key);\n                if (d instanceof Array) {\n                    data = d.concat(data);\n                } else if (d !== null) {\n                    var type = typeof d;\n                    if (type === typeof data && type === 'object') {\n                        for (var k in data) {\n                            d[k] = data[k];\n                        }\n                        data = d;\n                    } else {\n                        data = d + data;\n                    }\n                }\n                _.set(this._area, this._in(key), _.stringify(data, replacer));\n                return data;\n            },\n            remove: function(key, alt) {\n                var d = this.get(key, alt);\n                _.remove(this._area, this._in(key));\n                return d;\n            },\n            clear: function() {\n                if (!this._ns) {\n                    _.clear(this._area);\n                } else {\n                    this.each(function(k){ _.remove(this._area, this._in(k)); }, 1);\n                }\n                return this;\n            },\n            clearAll: function() {\n                var area = this._area;\n                for (var id in _.areas) {\n                    if (_.areas.hasOwnProperty(id)) {\n                        this._area = _.areas[id];\n                        this.clear();\n                    }\n                }\n                this._area = area;\n                return this;\n            },\n\n            // internal use functions\n            _in: function(k) {\n                if (typeof k !== \"string\"){ k = _.stringify(k); }\n                return this._ns ? this._ns + k : k;\n            },\n            _out: function(k) {\n                return this._ns ?\n                    k && k.indexOf(this._ns) === 0 ?\n                        k.substring(this._ns.length) :\n                        undefined : // so each() knows to skip it\n                    k;\n            }\n        },// end _.storeAPI\n        storage: function(name) {\n            return _.inherit(_.storageAPI, { items: {}, name: name });\n        },\n        storageAPI: {\n            length: 0,\n            has: function(k){ return this.items.hasOwnProperty(k); },\n            key: function(i) {\n                var c = 0;\n                for (var k in this.items){\n                    if (this.has(k) && i === c++) {\n                        return k;\n                    }\n                }\n            },\n            setItem: function(k, v) {\n                if (!this.has(k)) {\n                    this.length++;\n                }\n                this.items[k] = v;\n            },\n            removeItem: function(k) {\n                if (this.has(k)) {\n                    delete this.items[k];\n                    this.length--;\n                }\n            },\n            getItem: function(k){ return this.has(k) ? this.items[k] : null; },\n            clear: function(){ for (var k in this.items){ this.removeItem(k); } }\n        }// end _.storageAPI\n    };\n\n    var store =\n        // safely set this up (throws error in IE10/32bit mode for local files)\n        _.Store(\"local\", (function(){try{ return localStorage; }catch(e){}})());\n    store.local = store;// for completeness\n    store._ = _;// for extenders and debuggers...\n    // safely setup store.session (throws exception in FF for file:/// urls)\n    store.area(\"session\", (function(){try{ return sessionStorage; }catch(e){}})());\n    store.area(\"page\", _.storage(\"page\"));\n\n    if (typeof define === 'function' && define.amd !== undefined) {\n        define('store2', [], function () {\n            return store;\n        });\n    } else if ( true && module.exports) {\n        module.exports = store;\n    } else {\n        // expose the primary store fn to the global object and save conflicts\n        if (window.store){ _.conflict = window.store; }\n        window.store = store;\n    }\n\n})(this, this && this.define);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RvcmUyL2Rpc3Qvc3RvcmUyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsbUNBQW1DO0FBQ25DLENBQUM7QUFDRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlCQUFpQixvQ0FBb0MsVUFBVTtBQUMvRCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQ0FBa0MsMkJBQTJCO0FBQzdELDBDQUEwQyw0QkFBNEI7QUFDdEUscUNBQXFDLHVCQUF1QjtBQUM1RCxnQ0FBZ0MscUJBQXFCO0FBQ3JELGdDQUFnQyxxQkFBcUI7QUFDckQsK0JBQStCLGVBQWU7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxpREFBaUQsOENBQThDO0FBQy9GLHlDQUF5QztBQUN6Qyx5RUFBeUU7QUFDekUsZ0RBQWdEO0FBQ2hELDJCQUEyQjtBQUMzQiwrQ0FBK0M7QUFDL0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLGFBQWE7QUFDYiw4QkFBOEIsNEJBQTRCO0FBQzFELHNDQUFzQztBQUN0QyxzREFBc0QsS0FBSztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsS0FBSyxNQUFNO0FBQy9EO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1REFBdUQsZUFBZTtBQUN0RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esc0RBQXNELGFBQWEsZUFBZTtBQUNsRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsMkNBQTJDLG9DQUFvQztBQUMvRTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNkNBQTZDLFNBQVMsY0FBYztBQUNwRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhCQUE4QixzQ0FBc0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGtDQUFrQyw0Q0FBNEM7QUFDOUUsK0JBQStCLDJCQUEyQjtBQUMxRCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxLQUFLLHNCQUFzQixXQUFXO0FBQzNFLHdCQUF3QjtBQUN4QixnQkFBZ0I7QUFDaEI7QUFDQSxzQ0FBc0MsS0FBSyx3QkFBd0IsV0FBVztBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTSxTQUFTLEtBQTZCO0FBQzVDO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zoc29mdC8uL25vZGVfbW9kdWxlcy9zdG9yZTIvZGlzdC9zdG9yZTIuanM/MTJiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgc3RvcmUyIC0gdjIuMTQuMiAtIDIwMjItMDctMThcbiogQ29weXJpZ2h0IChjKSAyMDIyIE5hdGhhbiBCdWJuYTsgTGljZW5zZWQgKE1JVCBPUiBHUEwtMy4wKSAqL1xuOyhmdW5jdGlvbih3aW5kb3csIGRlZmluZSkge1xuICAgIHZhciBfID0ge1xuICAgICAgICB2ZXJzaW9uOiBcIjIuMTQuMlwiLFxuICAgICAgICBhcmVhczoge30sXG4gICAgICAgIGFwaXM6IHt9LFxuICAgICAgICBuc2RlbGltOiAnLicsXG5cbiAgICAgICAgLy8gdXRpbGl0aWVzXG4gICAgICAgIGluaGVyaXQ6IGZ1bmN0aW9uKGFwaSwgbykge1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBhcGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW8uaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIHAsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXBpLCBwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24oZCwgZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBkID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGQgPT09IFwiZnVuY3Rpb25cIiA/IGQrJycgOiBKU09OLnN0cmluZ2lmeShkLGZufHxfLnJlcGxhY2UpO1xuICAgICAgICB9LFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24ocywgZm4pIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGRvZXNuJ3QgcGFyc2UsIHJldHVybiBhcyBpc1xuICAgICAgICAgICAgdHJ5eyByZXR1cm4gSlNPTi5wYXJzZShzLGZufHxfLnJldml2ZSk7IH1jYXRjaChlKXsgcmV0dXJuIHM7IH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBleHRlbnNpb24gaG9va3NcbiAgICAgICAgZm46IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG4gICAgICAgICAgICBfLnN0b3JlQVBJW25hbWVdID0gZm47XG4gICAgICAgICAgICBmb3IgKHZhciBhcGkgaW4gXy5hcGlzKSB7XG4gICAgICAgICAgICAgICAgXy5hcGlzW2FwaV1bbmFtZV0gPSBmbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbihhcmVhLCBrZXkpeyByZXR1cm4gYXJlYS5nZXRJdGVtKGtleSk7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oYXJlYSwga2V5LCBzdHJpbmcpeyBhcmVhLnNldEl0ZW0oa2V5LCBzdHJpbmcpOyB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGFyZWEsIGtleSl7IGFyZWEucmVtb3ZlSXRlbShrZXkpOyB9LFxuICAgICAgICBrZXk6IGZ1bmN0aW9uKGFyZWEsIGkpeyByZXR1cm4gYXJlYS5rZXkoaSk7IH0sXG4gICAgICAgIGxlbmd0aDogZnVuY3Rpb24oYXJlYSl7IHJldHVybiBhcmVhLmxlbmd0aDsgfSxcbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKGFyZWEpeyBhcmVhLmNsZWFyKCk7IH0sXG5cbiAgICAgICAgLy8gY29yZSBmdW5jdGlvbnNcbiAgICAgICAgU3RvcmU6IGZ1bmN0aW9uKGlkLCBhcmVhLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHZhciBzdG9yZSA9IF8uaW5oZXJpdChfLnN0b3JlQVBJLCBmdW5jdGlvbihrZXksIGRhdGEsIG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKXsgcmV0dXJuIHN0b3JlLmdldEFsbCgpOyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcImZ1bmN0aW9uXCIpeyByZXR1cm4gc3RvcmUudHJhbnNhY3Qoa2V5LCBkYXRhLCBvdmVyd3JpdGUpOyB9Ly8gZm49ZGF0YSwgYWx0PW92ZXJ3cml0ZVxuICAgICAgICAgICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpeyByZXR1cm4gc3RvcmUuc2V0KGtleSwgZGF0YSwgb3ZlcndyaXRlKTsgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBrZXkgPT09IFwibnVtYmVyXCIpeyByZXR1cm4gc3RvcmUuZ2V0KGtleSk7IH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJmdW5jdGlvblwiKXsgcmV0dXJuIHN0b3JlLmVhY2goa2V5KTsgfVxuICAgICAgICAgICAgICAgIGlmICgha2V5KXsgcmV0dXJuIHN0b3JlLmNsZWFyKCk7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuc2V0QWxsKGtleSwgZGF0YSk7Ly8gb3ZlcndyaXRlPWRhdGEsIGRhdGE9a2V5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0b3JlLl9pZCA9IGlkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgdGVzdEtleSA9ICdfX3N0b3JlMl90ZXN0JztcbiAgICAgICAgICAgICAgICBhcmVhLnNldEl0ZW0odGVzdEtleSwgJ29rJyk7XG4gICAgICAgICAgICAgICAgc3RvcmUuX2FyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgIGFyZWEucmVtb3ZlSXRlbSh0ZXN0S2V5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5fYXJlYSA9IF8uc3RvcmFnZSgnZmFrZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmUuX25zID0gbmFtZXNwYWNlIHx8ICcnO1xuICAgICAgICAgICAgaWYgKCFfLmFyZWFzW2lkXSkge1xuICAgICAgICAgICAgICAgIF8uYXJlYXNbaWRdID0gc3RvcmUuX2FyZWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV8uYXBpc1tzdG9yZS5fbnMrc3RvcmUuX2lkXSkge1xuICAgICAgICAgICAgICAgIF8uYXBpc1tzdG9yZS5fbnMrc3RvcmUuX2lkXSA9IHN0b3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0b3JlO1xuICAgICAgICB9LFxuICAgICAgICBzdG9yZUFQSToge1xuICAgICAgICAgICAgLy8gYWRtaW4gZnVuY3Rpb25zXG4gICAgICAgICAgICBhcmVhOiBmdW5jdGlvbihpZCwgYXJlYSkge1xuICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRoaXNbaWRdO1xuICAgICAgICAgICAgICAgIGlmICghc3RvcmUgfHwgIXN0b3JlLmFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUgPSBfLlN0b3JlKGlkLCBhcmVhLCB0aGlzLl9ucyk7Ly9uZXcgYXJlYS1zcGVjaWZpYyBhcGkgaW4gdGhpcyBuYW1lc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzW2lkXSl7IHRoaXNbaWRdID0gc3RvcmU7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogZnVuY3Rpb24obmFtZXNwYWNlLCBzaW5nbGVBcmVhLCBkZWxpbSkge1xuICAgICAgICAgICAgICAgIGRlbGltID0gZGVsaW0gfHwgdGhpcy5fZGVsaW0gfHwgXy5uc2RlbGltO1xuICAgICAgICAgICAgICAgIGlmICghbmFtZXNwYWNlKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25zID8gdGhpcy5fbnMuc3Vic3RyaW5nKDAsdGhpcy5fbnMubGVuZ3RoLWRlbGltLmxlbmd0aCkgOiAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5zID0gbmFtZXNwYWNlLCBzdG9yZSA9IHRoaXNbbnNdO1xuICAgICAgICAgICAgICAgIGlmICghc3RvcmUgfHwgIXN0b3JlLm5hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZSA9IF8uU3RvcmUodGhpcy5faWQsIHRoaXMuX2FyZWEsIHRoaXMuX25zK25zK2RlbGltKTsvL25ldyBuYW1lc3BhY2VkIGFwaVxuICAgICAgICAgICAgICAgICAgICBzdG9yZS5fZGVsaW0gPSBkZWxpbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzW25zXSl7IHRoaXNbbnNdID0gc3RvcmU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaW5nbGVBcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIF8uYXJlYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5hcmVhKG5hbWUsIF8uYXJlYXNbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0Zha2U6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlYWwgPSB0aGlzLl9hcmVhO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcmVhID0gXy5zdG9yYWdlKCdmYWtlJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JjZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXJlYSA9IHRoaXMuX3JlYWwgfHwgdGhpcy5fYXJlYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FyZWEubmFtZSA9PT0gJ2Zha2UnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3N0b3JlJysodGhpcy5fbnM/Jy4nK3RoaXMubmFtZXNwYWNlKCk6JycpKydbJyt0aGlzLl9pZCsnXSc7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBzdG9yYWdlIGZ1bmN0aW9uc1xuICAgICAgICAgICAgaGFzOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXJlYS5oYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FyZWEuaGFzKHRoaXMuX2luKGtleSkpOy8vZXh0ZW5zaW9uIGhvb2tcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKHRoaXMuX2luKGtleSkgaW4gdGhpcy5fYXJlYSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2l6ZTogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMua2V5cygpLmxlbmd0aDsgfSxcbiAgICAgICAgICAgIGVhY2g6IGZ1bmN0aW9uKGZuLCBmaWxsKSB7Ly8gZmlsbCBpcyB1c2VkIGJ5IGtleXMoZmlsbExpc3QpIGFuZCBnZXRBbGwoZmlsbExpc3QpKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MCwgbT1fLmxlbmd0aCh0aGlzLl9hcmVhKTsgaTxtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX291dChfLmtleSh0aGlzLl9hcmVhLCBpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuLmNhbGwodGhpcywga2V5LCB0aGlzLmdldChrZXkpLCBmaWxsKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobSA+IF8ubGVuZ3RoKHRoaXMuX2FyZWEpKSB7IG0tLTsgaS0tOyB9Ly8gaW4gY2FzZSBvZiByZW1vdmVJdGVtXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmaWxsIHx8IHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5czogZnVuY3Rpb24oZmlsbExpc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGssIHYsIGxpc3QpeyBsaXN0LnB1c2goayk7IH0sIGZpbGxMaXN0IHx8IFtdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGtleSwgYWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBfLmdldCh0aGlzLl9hcmVhLCB0aGlzLl9pbihrZXkpKSxcbiAgICAgICAgICAgICAgICAgICAgZm47XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhbHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBmbiA9IGFsdDtcbiAgICAgICAgICAgICAgICAgICAgYWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMgIT09IG51bGwgPyBfLnBhcnNlKHMsIGZuKSA6XG4gICAgICAgICAgICAgICAgICAgIGFsdCAhPSBudWxsID8gYWx0IDogcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRBbGw6IGZ1bmN0aW9uKGZpbGxPYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGssIHYsIGFsbCl7IGFsbFtrXSA9IHY7IH0sIGZpbGxPYmogfHwge30pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYW5zYWN0OiBmdW5jdGlvbihrZXksIGZuLCBhbHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5nZXQoa2V5LCBhbHQpLFxuICAgICAgICAgICAgICAgICAgICByZXQgPSBmbih2YWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgcmV0ID09PSB1bmRlZmluZWQgPyB2YWwgOiByZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oa2V5LCBkYXRhLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IHRoaXMuZ2V0KGtleSksXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VyO1xuICAgICAgICAgICAgICAgIGlmIChkICE9IG51bGwgJiYgb3ZlcndyaXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvdmVyd3JpdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlciA9IG92ZXJ3cml0ZTtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcndyaXRlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zZXQodGhpcy5fYXJlYSwgdGhpcy5faW4oa2V5KSwgXy5zdHJpbmdpZnkoZGF0YSwgcmVwbGFjZXIpLCBvdmVyd3JpdGUpIHx8IGQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0QWxsOiBmdW5jdGlvbihkYXRhLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZCwgdmFsO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0KGtleSwgdmFsLCBvdmVyd3JpdGUpICE9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZDogZnVuY3Rpb24oa2V5LCBkYXRhLCByZXBsYWNlcikge1xuICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoZCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkLmNvbmNhdChkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IHR5cGVvZiBkYXRhICYmIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkW2tdID0gZGF0YVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGQgKyBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF8uc2V0KHRoaXMuX2FyZWEsIHRoaXMuX2luKGtleSksIF8uc3RyaW5naWZ5KGRhdGEsIHJlcGxhY2VyKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihrZXksIGFsdCkge1xuICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5nZXQoa2V5LCBhbHQpO1xuICAgICAgICAgICAgICAgIF8ucmVtb3ZlKHRoaXMuX2FyZWEsIHRoaXMuX2luKGtleSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX25zKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uY2xlYXIodGhpcy5fYXJlYSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGspeyBfLnJlbW92ZSh0aGlzLl9hcmVhLCB0aGlzLl9pbihrKSk7IH0sIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhckFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZWEgPSB0aGlzLl9hcmVhO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGlkIGluIF8uYXJlYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uYXJlYXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcmVhID0gXy5hcmVhc1tpZF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBpbnRlcm5hbCB1c2UgZnVuY3Rpb25zXG4gICAgICAgICAgICBfaW46IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGsgIT09IFwic3RyaW5nXCIpeyBrID0gXy5zdHJpbmdpZnkoayk7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbnMgPyB0aGlzLl9ucyArIGsgOiBrO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vdXQ6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbnMgP1xuICAgICAgICAgICAgICAgICAgICBrICYmIGsuaW5kZXhPZih0aGlzLl9ucykgPT09IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgay5zdWJzdHJpbmcodGhpcy5fbnMubGVuZ3RoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgOiAvLyBzbyBlYWNoKCkga25vd3MgdG8gc2tpcCBpdFxuICAgICAgICAgICAgICAgICAgICBrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LC8vIGVuZCBfLnN0b3JlQVBJXG4gICAgICAgIHN0b3JhZ2U6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfLmluaGVyaXQoXy5zdG9yYWdlQVBJLCB7IGl0ZW1zOiB7fSwgbmFtZTogbmFtZSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcmFnZUFQSToge1xuICAgICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICAgICAgaGFzOiBmdW5jdGlvbihrKXsgcmV0dXJuIHRoaXMuaXRlbXMuaGFzT3duUHJvcGVydHkoayk7IH0sXG4gICAgICAgICAgICBrZXk6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiB0aGlzLml0ZW1zKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGspICYmIGkgPT09IGMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0SXRlbTogZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXMoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtc1trXSA9IHY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlSXRlbTogZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhcyhrKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5pdGVtc1trXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SXRlbTogZnVuY3Rpb24oayl7IHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMuaXRlbXNba10gOiBudWxsOyB9LFxuICAgICAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKCl7IGZvciAodmFyIGsgaW4gdGhpcy5pdGVtcyl7IHRoaXMucmVtb3ZlSXRlbShrKTsgfSB9XG4gICAgICAgIH0vLyBlbmQgXy5zdG9yYWdlQVBJXG4gICAgfTtcblxuICAgIHZhciBzdG9yZSA9XG4gICAgICAgIC8vIHNhZmVseSBzZXQgdGhpcyB1cCAodGhyb3dzIGVycm9yIGluIElFMTAvMzJiaXQgbW9kZSBmb3IgbG9jYWwgZmlsZXMpXG4gICAgICAgIF8uU3RvcmUoXCJsb2NhbFwiLCAoZnVuY3Rpb24oKXt0cnl7IHJldHVybiBsb2NhbFN0b3JhZ2U7IH1jYXRjaChlKXt9fSkoKSk7XG4gICAgc3RvcmUubG9jYWwgPSBzdG9yZTsvLyBmb3IgY29tcGxldGVuZXNzXG4gICAgc3RvcmUuXyA9IF87Ly8gZm9yIGV4dGVuZGVycyBhbmQgZGVidWdnZXJzLi4uXG4gICAgLy8gc2FmZWx5IHNldHVwIHN0b3JlLnNlc3Npb24gKHRocm93cyBleGNlcHRpb24gaW4gRkYgZm9yIGZpbGU6Ly8vIHVybHMpXG4gICAgc3RvcmUuYXJlYShcInNlc3Npb25cIiwgKGZ1bmN0aW9uKCl7dHJ5eyByZXR1cm4gc2Vzc2lvblN0b3JhZ2U7IH1jYXRjaChlKXt9fSkoKSk7XG4gICAgc3RvcmUuYXJlYShcInBhZ2VcIiwgXy5zdG9yYWdlKFwicGFnZVwiKSk7XG5cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmaW5lKCdzdG9yZTInLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JlO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gc3RvcmU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZXhwb3NlIHRoZSBwcmltYXJ5IHN0b3JlIGZuIHRvIHRoZSBnbG9iYWwgb2JqZWN0IGFuZCBzYXZlIGNvbmZsaWN0c1xuICAgICAgICBpZiAod2luZG93LnN0b3JlKXsgXy5jb25mbGljdCA9IHdpbmRvdy5zdG9yZTsgfVxuICAgICAgICB3aW5kb3cuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG5cbn0pKHRoaXMsIHRoaXMgJiYgdGhpcy5kZWZpbmUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/store2/dist/store2.js\n");

/***/ })

};
;